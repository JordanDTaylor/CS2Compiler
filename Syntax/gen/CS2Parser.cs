//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/Users/Ming Slogar/Downloads/CS2Compiler-master\CS2.g4 by ANTLR 4.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6")]
[System.CLSCompliant(false)]
public partial class CS2Parser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		TYPE_BOOL=1, TYPE_INT=2, TYPE_DOUBLE=3, TYPE_STRING=4, TYPE_VOID=5, FALSE=6, 
		TRUE=7, IF=8, ELSE=9, FOR=10, WHILE=11, CONST=12, RETURN=13, PRIVATE=14, 
		PROTECTED=15, PUBLIC=16, SINGLE_QUOTE=17, DOUBLE_QOUTE=18, COMMA=19, OPEN_BRACKET=20, 
		CLOSE_BRACKET=21, OPEN_PAREN=22, CLOSE_PAREN=23, OPEN_BRACE=24, CLOSE_BRACE=25, 
		SEMICOLON=26, PLUS=27, MINUS=28, STAR=29, DIV=30, PERCENT=31, AMP=32, 
		BITWISE_OR=33, CARET=34, BANG=35, TILDE=36, ASSIGNMENT=37, LT=38, GT=39, 
		INTERR=40, DOUBLE_COLON=41, OP_COALESCING=42, OP_INC=43, OP_DEC=44, OP_AND=45, 
		OP_OR=46, OP_PTR=47, OP_EQ=48, OP_NE=49, OP_LE=50, OP_GE=51, REAL=52, 
		INTEGER=53, ID=54, LETTER=55, DIGIT=56, WS=57;
	public const int
		RULE_program = 0, RULE_declaration = 1, RULE_function_declaration = 2, 
		RULE_mod = 3, RULE_statement = 4, RULE_return_statement = 5, RULE_block = 6, 
		RULE_if_statement = 7, RULE_for_loop = 8, RULE_while_loop = 9, RULE_parameter_list = 10, 
		RULE_parameter = 11, RULE_assignment = 12, RULE_evaluatable = 13, RULE_operation = 14, 
		RULE_unary_operation = 15, RULE_relational_operation = 16, RULE_relop = 17, 
		RULE_expression = 18, RULE_multiplyingExpression = 19, RULE_atom = 20, 
		RULE_constant = 21, RULE_char_constant = 22, RULE_string_constant = 23, 
		RULE_function_call = 24, RULE_argument = 25, RULE_pre_unary_operator = 26, 
		RULE_post_unary_operator = 27, RULE_type = 28, RULE_arrayType = 29;
	public static readonly string[] ruleNames = {
		"program", "declaration", "function_declaration", "mod", "statement", 
		"return_statement", "block", "if_statement", "for_loop", "while_loop", 
		"parameter_list", "parameter", "assignment", "evaluatable", "operation", 
		"unary_operation", "relational_operation", "relop", "expression", "multiplyingExpression", 
		"atom", "constant", "char_constant", "string_constant", "function_call", 
		"argument", "pre_unary_operator", "post_unary_operator", "type", "arrayType"
	};

	private static readonly string[] _LiteralNames = {
		null, "'bool'", "'int'", "'double'", "'string'", "'void'", "'false'", 
		"'true'", "'if'", "'else'", "'for'", "'while'", "'const'", "'return'", 
		"'private'", "'protected'", "'public'", "'''", "'\"'", "','", "'['", "']'", 
		"'('", "')'", "'{'", "'}'", "';'", "'+'", "'-'", "'*'", "'/'", "'%'", 
		"'&'", "'|'", "'^'", "'!'", "'~'", "'='", "'<'", "'>'", "'?'", "'::'", 
		"'??'", "'++'", "'--'", "'&&'", "'||'", "'->'", "'=='", "'!='", "'<='", 
		"'>='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "TYPE_BOOL", "TYPE_INT", "TYPE_DOUBLE", "TYPE_STRING", "TYPE_VOID", 
		"FALSE", "TRUE", "IF", "ELSE", "FOR", "WHILE", "CONST", "RETURN", "PRIVATE", 
		"PROTECTED", "PUBLIC", "SINGLE_QUOTE", "DOUBLE_QOUTE", "COMMA", "OPEN_BRACKET", 
		"CLOSE_BRACKET", "OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACE", "CLOSE_BRACE", 
		"SEMICOLON", "PLUS", "MINUS", "STAR", "DIV", "PERCENT", "AMP", "BITWISE_OR", 
		"CARET", "BANG", "TILDE", "ASSIGNMENT", "LT", "GT", "INTERR", "DOUBLE_COLON", 
		"OP_COALESCING", "OP_INC", "OP_DEC", "OP_AND", "OP_OR", "OP_PTR", "OP_EQ", 
		"OP_NE", "OP_LE", "OP_GE", "REAL", "INTEGER", "ID", "LETTER", "DIGIT", 
		"WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CS2.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	static CS2Parser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

	public CS2Parser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class ProgramContext : ParserRuleContext {
		public Function_declarationContext[] function_declaration() {
			return GetRuleContexts<Function_declarationContext>();
		}
		public Function_declarationContext function_declaration(int i) {
			return GetRuleContext<Function_declarationContext>(i);
		}
		public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		public ITerminalNode[] SEMICOLON() { return GetTokens(CS2Parser.SEMICOLON); }
		public ITerminalNode SEMICOLON(int i) {
			return GetToken(CS2Parser.SEMICOLON, i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 66;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TYPE_INT) | (1L << TYPE_DOUBLE) | (1L << TYPE_STRING) | (1L << TYPE_VOID) | (1L << PRIVATE) | (1L << PUBLIC))) != 0)) {
				{
				State = 64;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
				case 1:
					{
					State = 60; function_declaration();
					}
					break;
				case 2:
					{
					State = 61; declaration();
					State = 62; Match(SEMICOLON);
					}
					break;
				}
				}
				State = 68;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode[] ID() { return GetTokens(CS2Parser.ID); }
		public ITerminalNode ID(int i) {
			return GetToken(CS2Parser.ID, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(CS2Parser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(CS2Parser.COMMA, i);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 2, RULE_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 69; type();
			State = 70; Match(ID);
			State = 75;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 71; Match(COMMA);
				State = 72; Match(ID);
				}
				}
				State = 77;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_declarationContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public Parameter_listContext parameter_list() {
			return GetRuleContext<Parameter_listContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ModContext mod() {
			return GetRuleContext<ModContext>(0);
		}
		public Function_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterFunction_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitFunction_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_declarationContext function_declaration() {
		Function_declarationContext _localctx = new Function_declarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_function_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PRIVATE || _la==PUBLIC) {
				{
				State = 78; mod();
				}
			}

			State = 81; type();
			State = 82; Match(ID);
			State = 83; Match(OPEN_PAREN);
			State = 84; parameter_list();
			State = 85; Match(CLOSE_PAREN);
			State = 86; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModContext : ParserRuleContext {
		public ITerminalNode PUBLIC() { return GetToken(CS2Parser.PUBLIC, 0); }
		public ITerminalNode PRIVATE() { return GetToken(CS2Parser.PRIVATE, 0); }
		public ModContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mod; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterMod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitMod(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMod(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModContext mod() {
		ModContext _localctx = new ModContext(Context, State);
		EnterRule(_localctx, 6, RULE_mod);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88;
			_la = TokenStream.LA(1);
			if ( !(_la==PRIVATE || _la==PUBLIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public For_loopContext for_loop() {
			return GetRuleContext<For_loopContext>(0);
		}
		public While_loopContext while_loop() {
			return GetRuleContext<While_loopContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public ITerminalNode SEMICOLON() { return GetToken(CS2Parser.SEMICOLON, 0); }
		public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Return_statementContext return_statement() {
			return GetRuleContext<Return_statementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_statement);
		try {
			State = 102;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 90; for_loop();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 91; while_loop();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 92; function_call();
				State = 93; Match(SEMICOLON);
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				{
				State = 95; declaration();
				State = 96; Match(SEMICOLON);
				}
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 98; assignment();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 99; block();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 100; if_statement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 101; return_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_statementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(CS2Parser.RETURN, 0); }
		public ITerminalNode SEMICOLON() { return GetToken(CS2Parser.SEMICOLON, 0); }
		public EvaluatableContext evaluatable() {
			return GetRuleContext<EvaluatableContext>(0);
		}
		public Return_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterReturn_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitReturn_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_statementContext return_statement() {
		Return_statementContext _localctx = new Return_statementContext(Context, State);
		EnterRule(_localctx, 10, RULE_return_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 104; Match(RETURN);
			State = 106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << SINGLE_QUOTE) | (1L << DOUBLE_QOUTE) | (1L << OPEN_PAREN) | (1L << MINUS) | (1L << OP_INC) | (1L << OP_DEC) | (1L << REAL) | (1L << ID))) != 0)) {
				{
				State = 105; evaluatable();
				}
			}

			State = 108; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public ITerminalNode OPEN_BRACE() { return GetToken(CS2Parser.OPEN_BRACE, 0); }
		public ITerminalNode CLOSE_BRACE() { return GetToken(CS2Parser.CLOSE_BRACE, 0); }
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 12, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 110; Match(OPEN_BRACE);
			State = 114;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TYPE_INT) | (1L << TYPE_DOUBLE) | (1L << TYPE_STRING) | (1L << TYPE_VOID) | (1L << IF) | (1L << FOR) | (1L << WHILE) | (1L << RETURN) | (1L << OPEN_BRACE) | (1L << ID))) != 0)) {
				{
				{
				State = 111; statement();
				}
				}
				State = 116;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 117; Match(CLOSE_BRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(CS2Parser.IF, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public EvaluatableContext evaluatable() {
			return GetRuleContext<EvaluatableContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(CS2Parser.ELSE, 0); }
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterIf_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitIf_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(Context, State);
		EnterRule(_localctx, 14, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119; Match(IF);
			State = 120; Match(OPEN_PAREN);
			State = 121; evaluatable();
			State = 122; Match(CLOSE_PAREN);
			State = 123; block();
			State = 126;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 124; Match(ELSE);
				State = 125; block();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_loopContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(CS2Parser.FOR, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public EvaluatableContext[] evaluatable() {
			return GetRuleContexts<EvaluatableContext>();
		}
		public EvaluatableContext evaluatable(int i) {
			return GetRuleContext<EvaluatableContext>(i);
		}
		public ITerminalNode SEMICOLON() { return GetToken(CS2Parser.SEMICOLON, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public For_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterFor_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitFor_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_loopContext for_loop() {
		For_loopContext _localctx = new For_loopContext(Context, State);
		EnterRule(_localctx, 16, RULE_for_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128; Match(FOR);
			State = 129; Match(OPEN_PAREN);
			State = 130; assignment();
			State = 131; evaluatable();
			State = 132; Match(SEMICOLON);
			State = 133; evaluatable();
			State = 134; Match(CLOSE_PAREN);
			State = 135; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class While_loopContext : ParserRuleContext {
		public ITerminalNode WHILE() { return GetToken(CS2Parser.WHILE, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public EvaluatableContext evaluatable() {
			return GetRuleContext<EvaluatableContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public While_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_while_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterWhile_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitWhile_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhile_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public While_loopContext while_loop() {
		While_loopContext _localctx = new While_loopContext(Context, State);
		EnterRule(_localctx, 18, RULE_while_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 137; Match(WHILE);
			State = 138; Match(OPEN_PAREN);
			State = 139; evaluatable();
			State = 140; Match(CLOSE_PAREN);
			State = 141; block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_listContext : ParserRuleContext {
		public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public Parameter_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterParameter_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitParameter_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_listContext parameter_list() {
		Parameter_listContext _localctx = new Parameter_listContext(Context, State);
		EnterRule(_localctx, 20, RULE_parameter_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TYPE_INT) | (1L << TYPE_DOUBLE) | (1L << TYPE_STRING) | (1L << TYPE_VOID))) != 0)) {
				{
				State = 143; parameter();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(Context, State);
		EnterRule(_localctx, 22, RULE_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146; type();
			State = 147; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(CS2Parser.ASSIGNMENT, 0); }
		public EvaluatableContext evaluatable() {
			return GetRuleContext<EvaluatableContext>(0);
		}
		public ITerminalNode SEMICOLON() { return GetToken(CS2Parser.SEMICOLON, 0); }
		public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(Context, State);
		EnterRule(_localctx, 24, RULE_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 151;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TYPE_INT:
			case TYPE_DOUBLE:
			case TYPE_STRING:
			case TYPE_VOID:
				{
				State = 149; declaration();
				}
				break;
			case ID:
				{
				State = 150; Match(ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 153; Match(ASSIGNMENT);
			State = 154; evaluatable();
			State = 155; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvaluatableContext : ParserRuleContext {
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public OperationContext operation() {
			return GetRuleContext<OperationContext>(0);
		}
		public EvaluatableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evaluatable; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterEvaluatable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitEvaluatable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvaluatable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvaluatableContext evaluatable() {
		EvaluatableContext _localctx = new EvaluatableContext(Context, State);
		EnterRule(_localctx, 26, RULE_evaluatable);
		try {
			State = 161;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 157; function_call();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 158; constant();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 159; Match(ID);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 160; operation();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperationContext : ParserRuleContext {
		public Unary_operationContext unary_operation() {
			return GetRuleContext<Unary_operationContext>(0);
		}
		public Relational_operationContext relational_operation() {
			return GetRuleContext<Relational_operationContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OperationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operation; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterOperation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitOperation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperationContext operation() {
		OperationContext _localctx = new OperationContext(Context, State);
		EnterRule(_localctx, 28, RULE_operation);
		try {
			State = 166;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 163; unary_operation();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 164; relational_operation();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 165; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_operationContext : ParserRuleContext {
		public Pre_unary_operatorContext pre_unary_operator() {
			return GetRuleContext<Pre_unary_operatorContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Post_unary_operatorContext post_unary_operator() {
			return GetRuleContext<Post_unary_operatorContext>(0);
		}
		public Unary_operationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_operation; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterUnary_operation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitUnary_operation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_operation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_operationContext unary_operation() {
		Unary_operationContext _localctx = new Unary_operationContext(Context, State);
		EnterRule(_localctx, 30, RULE_unary_operation);
		try {
			State = 174;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINUS:
			case OP_INC:
			case OP_DEC:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 168; pre_unary_operator();
				State = 169; expression();
				}
				}
				break;
			case OPEN_PAREN:
			case REAL:
			case ID:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 171; expression();
				State = 172; post_unary_operator();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_operationContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RelopContext relop() {
			return GetRuleContext<RelopContext>(0);
		}
		public Relational_operationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_operation; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterRelational_operation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitRelational_operation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_operation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_operationContext relational_operation() {
		Relational_operationContext _localctx = new Relational_operationContext(Context, State);
		EnterRule(_localctx, 32, RULE_relational_operation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176; expression();
			State = 177; relop();
			State = 178; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelopContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(CS2Parser.LT, 0); }
		public ITerminalNode GT() { return GetToken(CS2Parser.GT, 0); }
		public ITerminalNode OP_LE() { return GetToken(CS2Parser.OP_LE, 0); }
		public ITerminalNode OP_GE() { return GetToken(CS2Parser.OP_GE, 0); }
		public ITerminalNode OP_EQ() { return GetToken(CS2Parser.OP_EQ, 0); }
		public RelopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relop; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterRelop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitRelop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelopContext relop() {
		RelopContext _localctx = new RelopContext(Context, State);
		EnterRule(_localctx, 34, RULE_relop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 180;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << GT) | (1L << OP_EQ) | (1L << OP_LE) | (1L << OP_GE))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public MultiplyingExpressionContext[] multiplyingExpression() {
			return GetRuleContexts<MultiplyingExpressionContext>();
		}
		public MultiplyingExpressionContext multiplyingExpression(int i) {
			return GetRuleContext<MultiplyingExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(CS2Parser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(CS2Parser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(CS2Parser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(CS2Parser.MINUS, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 36, RULE_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182; multiplyingExpression();
			State = 187;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==PLUS || _la==MINUS) {
				{
				{
				State = 183;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 184; multiplyingExpression();
				}
				}
				State = 189;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyingExpressionContext : ParserRuleContext {
		public AtomContext[] atom() {
			return GetRuleContexts<AtomContext>();
		}
		public AtomContext atom(int i) {
			return GetRuleContext<AtomContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(CS2Parser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(CS2Parser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(CS2Parser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(CS2Parser.DIV, i);
		}
		public MultiplyingExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyingExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterMultiplyingExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitMultiplyingExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyingExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyingExpressionContext multiplyingExpression() {
		MultiplyingExpressionContext _localctx = new MultiplyingExpressionContext(Context, State);
		EnterRule(_localctx, 38, RULE_multiplyingExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 190; atom();
			State = 195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==STAR || _la==DIV) {
				{
				{
				State = 191;
				_la = TokenStream.LA(1);
				if ( !(_la==STAR || _la==DIV) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 192; atom();
				}
				}
				State = 197;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public ITerminalNode REAL() { return GetToken(CS2Parser.REAL, 0); }
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 40, RULE_atom);
		try {
			State = 205;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 198; Match(REAL);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 199; Match(ID);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 200; Match(OPEN_PAREN);
				State = 201; expression();
				State = 202; Match(CLOSE_PAREN);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 204; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode REAL() { return GetToken(CS2Parser.REAL, 0); }
		public Char_constantContext char_constant() {
			return GetRuleContext<Char_constantContext>(0);
		}
		public String_constantContext string_constant() {
			return GetRuleContext<String_constantContext>(0);
		}
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 42, RULE_constant);
		try {
			State = 210;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 207; Match(REAL);
				}
				break;
			case SINGLE_QUOTE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 208; char_constant();
				}
				break;
			case DOUBLE_QOUTE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 209; string_constant();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Char_constantContext : ParserRuleContext {
		public ITerminalNode[] SINGLE_QUOTE() { return GetTokens(CS2Parser.SINGLE_QUOTE); }
		public ITerminalNode SINGLE_QUOTE(int i) {
			return GetToken(CS2Parser.SINGLE_QUOTE, i);
		}
		public ITerminalNode LETTER() { return GetToken(CS2Parser.LETTER, 0); }
		public Char_constantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_char_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterChar_constant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitChar_constant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChar_constant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Char_constantContext char_constant() {
		Char_constantContext _localctx = new Char_constantContext(Context, State);
		EnterRule(_localctx, 44, RULE_char_constant);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212; Match(SINGLE_QUOTE);
			State = 213; Match(LETTER);
			State = 214; Match(SINGLE_QUOTE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_constantContext : ParserRuleContext {
		public ITerminalNode[] DOUBLE_QOUTE() { return GetTokens(CS2Parser.DOUBLE_QOUTE); }
		public ITerminalNode DOUBLE_QOUTE(int i) {
			return GetToken(CS2Parser.DOUBLE_QOUTE, i);
		}
		public ITerminalNode[] REAL() { return GetTokens(CS2Parser.REAL); }
		public ITerminalNode REAL(int i) {
			return GetToken(CS2Parser.REAL, i);
		}
		public ITerminalNode[] LETTER() { return GetTokens(CS2Parser.LETTER); }
		public ITerminalNode LETTER(int i) {
			return GetToken(CS2Parser.LETTER, i);
		}
		public String_constantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterString_constant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitString_constant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_constant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_constantContext string_constant() {
		String_constantContext _localctx = new String_constantContext(Context, State);
		EnterRule(_localctx, 46, RULE_string_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 216; Match(DOUBLE_QOUTE);
			State = 218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 217;
				_la = TokenStream.LA(1);
				if ( !(_la==REAL || _la==LETTER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				State = 220;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==REAL || _la==LETTER );
			State = 222; Match(DOUBLE_QOUTE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public ITerminalNode OPEN_PAREN() { return GetToken(CS2Parser.OPEN_PAREN, 0); }
		public ITerminalNode CLOSE_PAREN() { return GetToken(CS2Parser.CLOSE_PAREN, 0); }
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(CS2Parser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(CS2Parser.COMMA, i);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterFunction_call(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitFunction_call(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(Context, State);
		EnterRule(_localctx, 48, RULE_function_call);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 224; Match(ID);
			State = 225; Match(OPEN_PAREN);
			State = 237;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,20,Context) ) {
			case 1:
				{
				State = 227;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OPEN_PAREN) | (1L << MINUS) | (1L << OP_INC) | (1L << OP_DEC) | (1L << REAL) | (1L << ID))) != 0)) {
					{
					State = 226; argument();
					}
				}

				}
				break;
			case 2:
				{
				State = 229; argument();
				State = 234;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 230; Match(COMMA);
					State = 231; argument();
					}
					}
					State = 236;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			}
			State = 239; Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public OperationContext operation() {
			return GetRuleContext<OperationContext>(0);
		}
		public ITerminalNode ID() { return GetToken(CS2Parser.ID, 0); }
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 50, RULE_argument);
		try {
			State = 244;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 241; function_call();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 242; operation();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 243; Match(ID);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pre_unary_operatorContext : ParserRuleContext {
		public ITerminalNode MINUS() { return GetToken(CS2Parser.MINUS, 0); }
		public Post_unary_operatorContext post_unary_operator() {
			return GetRuleContext<Post_unary_operatorContext>(0);
		}
		public Pre_unary_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pre_unary_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterPre_unary_operator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitPre_unary_operator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPre_unary_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pre_unary_operatorContext pre_unary_operator() {
		Pre_unary_operatorContext _localctx = new Pre_unary_operatorContext(Context, State);
		EnterRule(_localctx, 52, RULE_pre_unary_operator);
		try {
			State = 248;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINUS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 246; Match(MINUS);
				}
				break;
			case OP_INC:
			case OP_DEC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 247; post_unary_operator();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Post_unary_operatorContext : ParserRuleContext {
		public ITerminalNode OP_INC() { return GetToken(CS2Parser.OP_INC, 0); }
		public ITerminalNode OP_DEC() { return GetToken(CS2Parser.OP_DEC, 0); }
		public Post_unary_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_post_unary_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterPost_unary_operator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitPost_unary_operator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPost_unary_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Post_unary_operatorContext post_unary_operator() {
		Post_unary_operatorContext _localctx = new Post_unary_operatorContext(Context, State);
		EnterRule(_localctx, 54, RULE_post_unary_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			_la = TokenStream.LA(1);
			if ( !(_la==OP_INC || _la==OP_DEC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public ITerminalNode TYPE_VOID() { return GetToken(CS2Parser.TYPE_VOID, 0); }
		public ITerminalNode TYPE_INT() { return GetToken(CS2Parser.TYPE_INT, 0); }
		public ITerminalNode TYPE_DOUBLE() { return GetToken(CS2Parser.TYPE_DOUBLE, 0); }
		public ITerminalNode TYPE_STRING() { return GetToken(CS2Parser.TYPE_STRING, 0); }
		public ArrayTypeContext arrayType() {
			return GetRuleContext<ArrayTypeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 56, RULE_type);
		try {
			State = 257;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 252; Match(TYPE_VOID);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 253; Match(TYPE_INT);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 254; Match(TYPE_DOUBLE);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 255; Match(TYPE_STRING);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 256; arrayType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayTypeContext : ParserRuleContext {
		public ITerminalNode OPEN_BRACKET() { return GetToken(CS2Parser.OPEN_BRACKET, 0); }
		public ITerminalNode CLOSE_BRACKET() { return GetToken(CS2Parser.CLOSE_BRACKET, 0); }
		public ITerminalNode TYPE_INT() { return GetToken(CS2Parser.TYPE_INT, 0); }
		public ITerminalNode TYPE_DOUBLE() { return GetToken(CS2Parser.TYPE_DOUBLE, 0); }
		public ITerminalNode TYPE_STRING() { return GetToken(CS2Parser.TYPE_STRING, 0); }
		public ArrayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayType; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.EnterArrayType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICS2Listener typedListener = listener as ICS2Listener;
			if (typedListener != null) typedListener.ExitArrayType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICS2Visitor<TResult> typedVisitor = visitor as ICS2Visitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayTypeContext arrayType() {
		ArrayTypeContext _localctx = new ArrayTypeContext(Context, State);
		EnterRule(_localctx, 58, RULE_arrayType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TYPE_INT) | (1L << TYPE_DOUBLE) | (1L << TYPE_STRING))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 260; Match(OPEN_BRACKET);
			State = 261; Match(CLOSE_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3;\x10A");
		sb.Append("\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a");
		sb.Append("\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4");
		sb.Append("\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4");
		sb.Append("\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4\x17\t\x17");
		sb.Append("\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B\x4\x1C");
		sb.Append("\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x3\x2\x3\x2\x3");
		sb.Append("\x2\x3\x2\a\x2\x43\n\x2\f\x2\xE\x2\x46\v\x2\x3\x3\x3\x3\x3\x3");
		sb.Append("\x3\x3\a\x3L\n\x3\f\x3\xE\x3O\v\x3\x3\x4\x5\x4R\n\x4\x3\x4\x3");
		sb.Append("\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x6\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5");
		sb.Append("\x6i\n\x6\x3\a\x3\a\x5\am\n\a\x3\a\x3\a\x3\b\x3\b\a\bs\n\b\f");
		sb.Append("\b\xE\bv\v\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5");
		sb.Append("\t\x81\n\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\v");
		sb.Append("\x3\v\x3\v\x3\v\x3\v\x3\v\x3\f\x5\f\x93\n\f\x3\r\x3\r\x3\r\x3");
		sb.Append("\xE\x3\xE\x5\xE\x9A\n\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xF\x3\xF");
		sb.Append("\x3\xF\x3\xF\x5\xF\xA4\n\xF\x3\x10\x3\x10\x3\x10\x5\x10\xA9");
		sb.Append("\n\x10\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\xB1");
		sb.Append("\n\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x14\x3\x14");
		sb.Append("\x3\x14\a\x14\xBC\n\x14\f\x14\xE\x14\xBF\v\x14\x3\x15\x3\x15");
		sb.Append("\x3\x15\a\x15\xC4\n\x15\f\x15\xE\x15\xC7\v\x15\x3\x16\x3\x16");
		sb.Append("\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\xD0\n\x16\x3\x17");
		sb.Append("\x3\x17\x3\x17\x5\x17\xD5\n\x17\x3\x18\x3\x18\x3\x18\x3\x18");
		sb.Append("\x3\x19\x3\x19\x6\x19\xDD\n\x19\r\x19\xE\x19\xDE\x3\x19\x3\x19");
		sb.Append("\x3\x1A\x3\x1A\x3\x1A\x5\x1A\xE6\n\x1A\x3\x1A\x3\x1A\x3\x1A");
		sb.Append("\a\x1A\xEB\n\x1A\f\x1A\xE\x1A\xEE\v\x1A\x5\x1A\xF0\n\x1A\x3");
		sb.Append("\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1B\x5\x1B\xF7\n\x1B\x3\x1C\x3");
		sb.Append("\x1C\x5\x1C\xFB\n\x1C\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x3\x1E\x3");
		sb.Append("\x1E\x3\x1E\x5\x1E\x104\n\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3");
		sb.Append("\x1F\x2\x2 \x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E");
		sb.Append(" \"$&(*,.\x30\x32\x34\x36\x38:<\x2\t\x4\x2\x10\x10\x12\x12\x5");
		sb.Append("\x2()\x32\x32\x34\x35\x3\x2\x1D\x1E\x3\x2\x1F \x4\x2\x36\x36");
		sb.Append("\x39\x39\x3\x2-.\x3\x2\x4\x6\x113\x2\x44\x3\x2\x2\x2\x4G\x3");
		sb.Append("\x2\x2\x2\x6Q\x3\x2\x2\x2\bZ\x3\x2\x2\x2\nh\x3\x2\x2\x2\fj\x3");
		sb.Append("\x2\x2\x2\xEp\x3\x2\x2\x2\x10y\x3\x2\x2\x2\x12\x82\x3\x2\x2");
		sb.Append("\x2\x14\x8B\x3\x2\x2\x2\x16\x92\x3\x2\x2\x2\x18\x94\x3\x2\x2");
		sb.Append("\x2\x1A\x99\x3\x2\x2\x2\x1C\xA3\x3\x2\x2\x2\x1E\xA8\x3\x2\x2");
		sb.Append("\x2 \xB0\x3\x2\x2\x2\"\xB2\x3\x2\x2\x2$\xB6\x3\x2\x2\x2&\xB8");
		sb.Append("\x3\x2\x2\x2(\xC0\x3\x2\x2\x2*\xCF\x3\x2\x2\x2,\xD4\x3\x2\x2");
		sb.Append("\x2.\xD6\x3\x2\x2\x2\x30\xDA\x3\x2\x2\x2\x32\xE2\x3\x2\x2\x2");
		sb.Append("\x34\xF6\x3\x2\x2\x2\x36\xFA\x3\x2\x2\x2\x38\xFC\x3\x2\x2\x2");
		sb.Append(":\x103\x3\x2\x2\x2<\x105\x3\x2\x2\x2>\x43\x5\x6\x4\x2?@\x5\x4");
		sb.Append("\x3\x2@\x41\a\x1C\x2\x2\x41\x43\x3\x2\x2\x2\x42>\x3\x2\x2\x2");
		sb.Append("\x42?\x3\x2\x2\x2\x43\x46\x3\x2\x2\x2\x44\x42\x3\x2\x2\x2\x44");
		sb.Append("\x45\x3\x2\x2\x2\x45\x3\x3\x2\x2\x2\x46\x44\x3\x2\x2\x2GH\x5");
		sb.Append(":\x1E\x2HM\a\x38\x2\x2IJ\a\x15\x2\x2JL\a\x38\x2\x2KI\x3\x2\x2");
		sb.Append("\x2LO\x3\x2\x2\x2MK\x3\x2\x2\x2MN\x3\x2\x2\x2N\x5\x3\x2\x2\x2");
		sb.Append("OM\x3\x2\x2\x2PR\x5\b\x5\x2QP\x3\x2\x2\x2QR\x3\x2\x2\x2RS\x3");
		sb.Append("\x2\x2\x2ST\x5:\x1E\x2TU\a\x38\x2\x2UV\a\x18\x2\x2VW\x5\x16");
		sb.Append("\f\x2WX\a\x19\x2\x2XY\x5\xE\b\x2Y\a\x3\x2\x2\x2Z[\t\x2\x2\x2");
		sb.Append("[\t\x3\x2\x2\x2\\i\x5\x12\n\x2]i\x5\x14\v\x2^_\x5\x32\x1A\x2");
		sb.Append("_`\a\x1C\x2\x2`i\x3\x2\x2\x2\x61\x62\x5\x4\x3\x2\x62\x63\a\x1C");
		sb.Append("\x2\x2\x63i\x3\x2\x2\x2\x64i\x5\x1A\xE\x2\x65i\x5\xE\b\x2\x66");
		sb.Append("i\x5\x10\t\x2gi\x5\f\a\x2h\\\x3\x2\x2\x2h]\x3\x2\x2\x2h^\x3");
		sb.Append("\x2\x2\x2h\x61\x3\x2\x2\x2h\x64\x3\x2\x2\x2h\x65\x3\x2\x2\x2");
		sb.Append("h\x66\x3\x2\x2\x2hg\x3\x2\x2\x2i\v\x3\x2\x2\x2jl\a\xF\x2\x2");
		sb.Append("km\x5\x1C\xF\x2lk\x3\x2\x2\x2lm\x3\x2\x2\x2mn\x3\x2\x2\x2no");
		sb.Append("\a\x1C\x2\x2o\r\x3\x2\x2\x2pt\a\x1A\x2\x2qs\x5\n\x6\x2rq\x3");
		sb.Append("\x2\x2\x2sv\x3\x2\x2\x2tr\x3\x2\x2\x2tu\x3\x2\x2\x2uw\x3\x2");
		sb.Append("\x2\x2vt\x3\x2\x2\x2wx\a\x1B\x2\x2x\xF\x3\x2\x2\x2yz\a\n\x2");
		sb.Append("\x2z{\a\x18\x2\x2{|\x5\x1C\xF\x2|}\a\x19\x2\x2}\x80\x5\xE\b");
		sb.Append("\x2~\x7F\a\v\x2\x2\x7F\x81\x5\xE\b\x2\x80~\x3\x2\x2\x2\x80\x81");
		sb.Append("\x3\x2\x2\x2\x81\x11\x3\x2\x2\x2\x82\x83\a\f\x2\x2\x83\x84\a");
		sb.Append("\x18\x2\x2\x84\x85\x5\x1A\xE\x2\x85\x86\x5\x1C\xF\x2\x86\x87");
		sb.Append("\a\x1C\x2\x2\x87\x88\x5\x1C\xF\x2\x88\x89\a\x19\x2\x2\x89\x8A");
		sb.Append("\x5\xE\b\x2\x8A\x13\x3\x2\x2\x2\x8B\x8C\a\r\x2\x2\x8C\x8D\a");
		sb.Append("\x18\x2\x2\x8D\x8E\x5\x1C\xF\x2\x8E\x8F\a\x19\x2\x2\x8F\x90");
		sb.Append("\x5\xE\b\x2\x90\x15\x3\x2\x2\x2\x91\x93\x5\x18\r\x2\x92\x91");
		sb.Append("\x3\x2\x2\x2\x92\x93\x3\x2\x2\x2\x93\x17\x3\x2\x2\x2\x94\x95");
		sb.Append("\x5:\x1E\x2\x95\x96\a\x38\x2\x2\x96\x19\x3\x2\x2\x2\x97\x9A");
		sb.Append("\x5\x4\x3\x2\x98\x9A\a\x38\x2\x2\x99\x97\x3\x2\x2\x2\x99\x98");
		sb.Append("\x3\x2\x2\x2\x9A\x9B\x3\x2\x2\x2\x9B\x9C\a\'\x2\x2\x9C\x9D\x5");
		sb.Append("\x1C\xF\x2\x9D\x9E\a\x1C\x2\x2\x9E\x1B\x3\x2\x2\x2\x9F\xA4\x5");
		sb.Append("\x32\x1A\x2\xA0\xA4\x5,\x17\x2\xA1\xA4\a\x38\x2\x2\xA2\xA4\x5");
		sb.Append("\x1E\x10\x2\xA3\x9F\x3\x2\x2\x2\xA3\xA0\x3\x2\x2\x2\xA3\xA1");
		sb.Append("\x3\x2\x2\x2\xA3\xA2\x3\x2\x2\x2\xA4\x1D\x3\x2\x2\x2\xA5\xA9");
		sb.Append("\x5 \x11\x2\xA6\xA9\x5\"\x12\x2\xA7\xA9\x5&\x14\x2\xA8\xA5\x3");
		sb.Append("\x2\x2\x2\xA8\xA6\x3\x2\x2\x2\xA8\xA7\x3\x2\x2\x2\xA9\x1F\x3");
		sb.Append("\x2\x2\x2\xAA\xAB\x5\x36\x1C\x2\xAB\xAC\x5&\x14\x2\xAC\xB1\x3");
		sb.Append("\x2\x2\x2\xAD\xAE\x5&\x14\x2\xAE\xAF\x5\x38\x1D\x2\xAF\xB1\x3");
		sb.Append("\x2\x2\x2\xB0\xAA\x3\x2\x2\x2\xB0\xAD\x3\x2\x2\x2\xB1!\x3\x2");
		sb.Append("\x2\x2\xB2\xB3\x5&\x14\x2\xB3\xB4\x5$\x13\x2\xB4\xB5\x5&\x14");
		sb.Append("\x2\xB5#\x3\x2\x2\x2\xB6\xB7\t\x3\x2\x2\xB7%\x3\x2\x2\x2\xB8");
		sb.Append("\xBD\x5(\x15\x2\xB9\xBA\t\x4\x2\x2\xBA\xBC\x5(\x15\x2\xBB\xB9");
		sb.Append("\x3\x2\x2\x2\xBC\xBF\x3\x2\x2\x2\xBD\xBB\x3\x2\x2\x2\xBD\xBE");
		sb.Append("\x3\x2\x2\x2\xBE\'\x3\x2\x2\x2\xBF\xBD\x3\x2\x2\x2\xC0\xC5\x5");
		sb.Append("*\x16\x2\xC1\xC2\t\x5\x2\x2\xC2\xC4\x5*\x16\x2\xC3\xC1\x3\x2");
		sb.Append("\x2\x2\xC4\xC7\x3\x2\x2\x2\xC5\xC3\x3\x2\x2\x2\xC5\xC6\x3\x2");
		sb.Append("\x2\x2\xC6)\x3\x2\x2\x2\xC7\xC5\x3\x2\x2\x2\xC8\xD0\a\x36\x2");
		sb.Append("\x2\xC9\xD0\a\x38\x2\x2\xCA\xCB\a\x18\x2\x2\xCB\xCC\x5&\x14");
		sb.Append("\x2\xCC\xCD\a\x19\x2\x2\xCD\xD0\x3\x2\x2\x2\xCE\xD0\x5\x32\x1A");
		sb.Append("\x2\xCF\xC8\x3\x2\x2\x2\xCF\xC9\x3\x2\x2\x2\xCF\xCA\x3\x2\x2");
		sb.Append("\x2\xCF\xCE\x3\x2\x2\x2\xD0+\x3\x2\x2\x2\xD1\xD5\a\x36\x2\x2");
		sb.Append("\xD2\xD5\x5.\x18\x2\xD3\xD5\x5\x30\x19\x2\xD4\xD1\x3\x2\x2\x2");
		sb.Append("\xD4\xD2\x3\x2\x2\x2\xD4\xD3\x3\x2\x2\x2\xD5-\x3\x2\x2\x2\xD6");
		sb.Append("\xD7\a\x13\x2\x2\xD7\xD8\a\x39\x2\x2\xD8\xD9\a\x13\x2\x2\xD9");
		sb.Append("/\x3\x2\x2\x2\xDA\xDC\a\x14\x2\x2\xDB\xDD\t\x6\x2\x2\xDC\xDB");
		sb.Append("\x3\x2\x2\x2\xDD\xDE\x3\x2\x2\x2\xDE\xDC\x3\x2\x2\x2\xDE\xDF");
		sb.Append("\x3\x2\x2\x2\xDF\xE0\x3\x2\x2\x2\xE0\xE1\a\x14\x2\x2\xE1\x31");
		sb.Append("\x3\x2\x2\x2\xE2\xE3\a\x38\x2\x2\xE3\xEF\a\x18\x2\x2\xE4\xE6");
		sb.Append("\x5\x34\x1B\x2\xE5\xE4\x3\x2\x2\x2\xE5\xE6\x3\x2\x2\x2\xE6\xF0");
		sb.Append("\x3\x2\x2\x2\xE7\xEC\x5\x34\x1B\x2\xE8\xE9\a\x15\x2\x2\xE9\xEB");
		sb.Append("\x5\x34\x1B\x2\xEA\xE8\x3\x2\x2\x2\xEB\xEE\x3\x2\x2\x2\xEC\xEA");
		sb.Append("\x3\x2\x2\x2\xEC\xED\x3\x2\x2\x2\xED\xF0\x3\x2\x2\x2\xEE\xEC");
		sb.Append("\x3\x2\x2\x2\xEF\xE5\x3\x2\x2\x2\xEF\xE7\x3\x2\x2\x2\xF0\xF1");
		sb.Append("\x3\x2\x2\x2\xF1\xF2\a\x19\x2\x2\xF2\x33\x3\x2\x2\x2\xF3\xF7");
		sb.Append("\x5\x32\x1A\x2\xF4\xF7\x5\x1E\x10\x2\xF5\xF7\a\x38\x2\x2\xF6");
		sb.Append("\xF3\x3\x2\x2\x2\xF6\xF4\x3\x2\x2\x2\xF6\xF5\x3\x2\x2\x2\xF7");
		sb.Append("\x35\x3\x2\x2\x2\xF8\xFB\a\x1E\x2\x2\xF9\xFB\x5\x38\x1D\x2\xFA");
		sb.Append("\xF8\x3\x2\x2\x2\xFA\xF9\x3\x2\x2\x2\xFB\x37\x3\x2\x2\x2\xFC");
		sb.Append("\xFD\t\a\x2\x2\xFD\x39\x3\x2\x2\x2\xFE\x104\a\a\x2\x2\xFF\x104");
		sb.Append("\a\x4\x2\x2\x100\x104\a\x5\x2\x2\x101\x104\a\x6\x2\x2\x102\x104");
		sb.Append("\x5<\x1F\x2\x103\xFE\x3\x2\x2\x2\x103\xFF\x3\x2\x2\x2\x103\x100");
		sb.Append("\x3\x2\x2\x2\x103\x101\x3\x2\x2\x2\x103\x102\x3\x2\x2\x2\x104");
		sb.Append(";\x3\x2\x2\x2\x105\x106\t\b\x2\x2\x106\x107\a\x16\x2\x2\x107");
		sb.Append("\x108\a\x17\x2\x2\x108=\x3\x2\x2\x2\x1A\x42\x44MQhlt\x80\x92");
		sb.Append("\x99\xA3\xA8\xB0\xBD\xC5\xCF\xD4\xDE\xE5\xEC\xEF\xF6\xFA\x103");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());


}
